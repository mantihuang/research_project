# axis(1, hh, c("", "1 quarter", "", "", "1 year", "", "", "", "2 years"))
axis(2, c(0, 50, 100), c("", "FEVD[au.rgdp]", ""))
for (n in 1:N) {
polygon(c(hh, (h + 1):1), c(fevd.au.rgdp[n, hh], fevd.au.rgdp[n + 1, (h + 1):1]), col = colors[n], border = colors[n])
}
# axis(4, (0.5 * (fevd.au.rgdp[1:n, 9] + fevd.au.rgdp[2:n+1, 9]))[c(1, 3, 10)], c("Government spending shock", "", "au.mps"))
axis(4, (0.5 * (fevd.au.rgdp[1:n, 9] + fevd.au.rgdp[2:n+1, 9])))
# Plotting fevd-au-p-k1
plot(hh, fevd.realTWI[1,], type = "n", ylim = c(0, 100), axes = FALSE, xlab = "", ylab = "")
axis(1, hh, x_axis_labels)
axis(2, c(0, 50, 100), c("", "FEVD[realTWI]", ""))
for (n in 1:N) {
polygon(c(hh, (h + 1):1), c(fevd.realTWI[n, hh], fevd.realTWI[n + 1, (h + 1):1]), col = colors[n], border = colors[n])
}
# axis(4, (0.5 * (fevd.realTWI[1:n, 9] + fevd.realTWI[2:n+1, 9]))[c(3, 10)],)
axis(4, (0.5 * (fevd.realTWI[1:n, 9] + fevd.realTWI[2:n+1, 9])))
T             = dim(aux$Y)[1]
T             = dim(Y)[1]
N             = dim(Y)[2]
K             = dim(X)[2]
H         = diag(T)
sdiag(H,-1) =  -1
HH        = 2*diag(T)
sdiag(HH,-1) =  -1
sdiag(HH,1) =  -1
priors        = list(
h0.v    = 1,
sigmav.s= 1,
sigmav.nu= 1,
h0.v    = 1,
h0.m    = 0 ,
HH      = HH
)
sv1 = SVcommon.Gibbs.iteration(S,Y,X,priors)
sv1 = SVcommon.Gibbs.iteration(S,Y,X,priors)
#| code-fold: true
#| code-summary: "Show code"
SVcommon.Gibbs.iteration = function(S,Y,X, priors){
# priors is a list containing:
#   h0.v - a positive scalar
#   h0.m - a scalar
#   sigmav.s - a positive scalar
#   sigmav.nu - a positive scalar
#   HH - a TxT matrix
aux     = list(
Y           = Y,
X           = X,
H           = matrix(1,T,1),
h0          = 0,
sigma.v2      = 1,
s           = matrix(1,T,1),
A          = matrix(0, K, N),
Sigma      = matrix(0, K, N),
sigma2    = matrix(1,T,1)
)
T             = dim(aux$Y)[1]
N             = dim(aux$Y)[2]
K             = dim(X)[2]
posteriors      = list(
H           = matrix(NA,T,S),
sigma2      = matrix(NA,T,S),
s           = matrix(NA,T,S),
h0          = rep(NA,S),
sigma.v2    = rep(NA,S),
A           = array(NA, c(K,N,S)),
Sigma       = array(NA, c(N,N,S))
)
# Sampling A and Sigma
kappa.1     = 10
kappa.2     = 100
kappa.3     = 1
A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y
Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)
# Prior distribution specification - Minnesota prior
A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))
A.prior[2:(N + 1), ] = diag(N)
S.prior     = diag(diag(Sigma.hat))
V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))
nu.prior    = 8
#####
alpha.st      = c(1.92677,1.34744,0.73504,0.02266,0-0.85173,-1.97278,-3.46788,-5.55246,-8.68384,-14.65000)
sigma.st      = c(0.11265,0.17788,0.26768,0.40611,0.62699,0.98583,1.57469,2.54498,4.16591,7.33342)
pi.st         = c(0.00609,0.04775,0.13057,0.20674,0.22715,0.18842,0.12047,0.05591,0.01575,0.00115)
for (s in 1:S){
# normal-inverse Wishard posterior parameters
V.bar.inv   = t(aux$X)%*%diag(1/as.vector(aux$sigma2))%*%aux$X + diag(1/diag(V.prior))
V.bar       = solve(V.bar.inv)
A.bar       = V.bar%*%(t(aux$X)%*%diag(1/as.vector(aux$sigma2))%*%aux$Y + diag(1/diag(V.prior))%*%A.prior)
nu.bar      = nrow(aux$Y) + nu.prior
S.bar       = S.prior + t(aux$Y)%*%diag(1/as.vector(aux$sigma2))%*%aux$Y +   t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar
S.bar.inv   = solve(S.bar)
# posterior draws
############################################################
Sigma.posterior.IW     = rWishart(1, df=nu.bar, Sigma=S.bar.inv)
Sigma.posterior.draw   = apply(Sigma.posterior.IW, 3 ,solve)
aux$Sigma              = array(Sigma.posterior.draw,c(N,N,1))
A.norm                 = array(rnorm(prod(c(K,N,1))),c(K,N,1))
L                      = t(chol(V.bar))
aux$A                  = A.bar + L%*%A.norm[,,1]%*%chol(aux$Sigma[,,1])
# Lambda        = solve(chol(S.prior))
Lambda        = solve(chol(aux$Sigma[,,1]))
Z             = rowSums( ( aux$Y - aux$X %*% aux$A ) %*% Lambda ) / sqrt(N)
Y.tilde       = as.vector(log((Z + 0.0000001)^2))
Ytilde.alpha  = as.matrix(Y.tilde - alpha.st[as.vector(aux$s)])
# sampling initial condition
############################################################
V.h0.bar      = 1/((1 / priors$h0.v) + (1 / aux$sigma.v2))
m.h0.bar      = V.h0.bar*((priors$h0.m / priors$h0.v) + (aux$H[1] / aux$sigma.v2))
h0.draw       = rnorm(1, mean = m.h0.bar, sd = sqrt(V.h0.bar))
aux$h0        = h0.draw
# sampling sigma.v2
############################################################
sigma.v2.s    = priors$sigmav.s + sum(c(aux$H[1] - aux$h0, diff(aux$H))^2)
sigma.v2.draw = sigma.v2.s / rchisq(1, priors$sigmav.nu + T)
aux$sigma.v2  = sigma.v2.draw
# sampling auxiliary states
############################################################
Pr.tmp        = simplify2array(lapply(1:10,function(x){
dnorm(Y.tilde, mean = as.vector(aux$H + alpha.st[x]), sd = sqrt(sigma.st[x]), log = TRUE) + log(pi.st[x])
}))
Pr            = t(apply(Pr.tmp, 1, function(x){exp(x - max(x)) / sum(exp(x - max(x)))}))
s.cum         = t(apply(Pr, 1, cumsum))
r             = matrix(rep(runif(T), 10), ncol = 10)
ss            = apply(s.cum < r, 1, sum) + 1
aux$s         = as.matrix(ss)
# sampling log-volatilities using functions for tridiagonal precision matrix
############################################################
Sigma.s.inv   = diag(1 / sigma.st[as.vector(aux$s)])
D.inv         = Sigma.s.inv + (1 / aux$sigma.v2) * priors$HH
b             = as.matrix(Ytilde.alpha / sigma.st[as.vector(aux$s)] + (aux$h0/aux$sigma.v2)*diag(T)[,1])
lead.diag     = diag(D.inv)
sub.diag      = mgcv::sdiag(D.inv, -1)
D.chol        = mgcv::trichol(ld = lead.diag, sd = sub.diag)
D.L           = diag(D.chol$ld)
mgcv::sdiag(D.L,-1) = D.chol$sd
x             = as.matrix(rnorm(T))
a             = forwardsolve(D.L, b)
draw          = backsolve(t(D.L), a + x)
aux$H         = as.matrix(draw)
aux$sigma2    = as.matrix(exp(draw))
posteriors$H[,s]             = aux$H
posteriors$sigma2[,s]        = aux$sigma2
posteriors$s[,s]             = aux$s
posteriors$h0[s]             = aux$h0
posteriors$sigma.v2[s]       = aux$sigma.v2
posteriors$A[,,s]            = aux$A
posteriors$Sigma[,,s]        = aux$Sigma
posteriors$A[,,s]            = aux$A
posteriors$Sigma[,,s]        = aux$Sigma
}
return(posteriors)
}
T             = dim(Y)[1]
N             = dim(Y)[2]
K             = dim(X)[2]
H         = diag(T)
sdiag(H,-1) =  -1
HH        = 2*diag(T)
sdiag(HH,-1) =  -1
sdiag(HH,1) =  -1
priors        = list(
h0.v    = 1,
sigmav.s= 1,
sigmav.nu= 1,
h0.v    = 1,
h0.m    = 0 ,
HH      = HH
)
sv1 = SVcommon.Gibbs.iteration(S,Y,X,priors)
A.posterior= sv1$A
B.posterior       = array(NA,c(N,N,S))
B1.posterior = array(NA,c(N,(1+N*p),S))
for (s in 1:S){
cholSigma.s     = chol(sv1$Sigma[,,s])
B.posterior[,,s]= t(cholSigma.s)
B1.posterior[,,s] =  B.posterior[,,s]%*%t(A.posterior[,,s])
}
sv_posterior = list(A.posterior = A.posterior, B.posterior = B.posterior, Sigma.posterior = sv1$Sigma,B1.posterior = B1.posterior)
SV_Narrative_Restriction = NarrativeSignRestrictions(sign.restrictions = c(1,1,0,0,0,1,1,1), sv_posterior,c(16,50,80,156,204),Y,X)
A.posterior = SV_Narrative_Restriction$A.draws
B.posterior = SV_Narrative_Restriction$B.draws
# Calculate the means
Ahcheck_mean <- head(round(apply(A.posterior, 1:2, mean),4))
# Calculate the standard deviations
Ahcheck_sd <- head(round(apply(A.posterior, 1:2, sd),4))
Ahcheck_mean
Ahcheck_sd
# Calculate the means
Bhcheck_mean <- head(round(apply(B.posterior, 1:2, mean),4))
Bhcheck_sd   <- head(round(apply(B.posterior, 1:2, sd),4))
# Calculate the standard deviations
Bhcheck_mean
Bhcheck_sd
par(mfrow=c(2,2), mar=c(4,4,2,2))
plot.ts(A.posterior[3,,][8,], xlab = "Simulation times S", ylab = expression(A[38]), col = "#CC66CC")
hist(A.posterior[3,,][8,], xlab = expression(A[38]), col = "#CC66CC", main = '')
plot.ts(B.posterior[3,,][8,], xlab = "Simulation times S", ylab = expression(B[38]), col = "lightblue")
hist(B.posterior[3,,][8,], xlab = expression(A[38]), col = "lightblue", main = '')
h = 20
IRF.posterior     = array(NA,c(N,N,h+1,S))
IRF.inf.posterior = array(NA,c(N,N,S))
FEVD.posterior    = array(NA,c(N,N,h+1,S))
J                 = cbind(diag(N),matrix(0,N,N*(p-1)))
for (s in 1:S){
A.bold          = rbind(t(A.posterior[2:(1+N*p),,s]),cbind(diag(N*(p-1)),matrix(0,N*(p-1),N)))
IRF.inf.posterior[,,s]          = J %*% solve(diag(N*p)-A.bold) %*% t(J) %*% B.posterior[,,s]
A.bold.power    = A.bold
for (i in 1:(h+1)){
if (i==1){
IRF.posterior[,,i,s]        = B.posterior[,,s]
} else {
IRF.posterior[,,i,s]        = J %*% A.bold.power %*% t(J) %*% B.posterior[,,s]
A.bold.power                = A.bold.power %*% A.bold
}
for (n in 1:N){
for (nn in 1:N){
FEVD.posterior[n,nn,i,s]  = sum(IRF.posterior[n,nn,1:i,s]^2)
}
}
FEVD.posterior[,,i,s]         = diag(1/apply(FEVD.posterior[,,i,s],1,sum))%*%FEVD.posterior[,,i,s]
}
}
FEVD.posterior    = 100*FEVD.posterior
# save(IRF.posterior,IRF.inf.posterior, FEVD.posterior, file="irf-fevd-k002.RData")
save(IRF.posterior,IRF.inf.posterior, FEVD.posterior, file="irf-fevd-k1_narrative.RData")
load("irf-fevd-k1_narrative.RData")
IRFs.k1           = apply(IRF.posterior[,1,,],1:2,mean)
######1st shock is government  spending shock
IRFs.inf.k1       = apply(IRF.inf.posterior[,1,],1,mean)
rownames(IRFs.k1) = colnames(Y)
IRFs.k1.hdi    = apply(IRF.posterior[,1,,],1:2,hdi, credMass=0.68)
hh          = 1:h+1
par(mfrow=c(3,3), mar=c(4,4.5,2,2),cex.axis=1.5, cex.lab=1.5)
# par(mfrow=c(4,2), mar=c(3,3,2,2),cex.axis=1.5, cex.lab=1.5)
for (n in 1:N){
ylims     = range(IRFs.k1[n,hh],IRFs.k1.hdi[,n,hh])
plot(hh,IRFs.k1[n,hh], type="l", ylim=ylims, axes=FALSE, xlab="", ylab=rownames(IRFs.k1)[n])
# if (n==N-1 | n==N){
#   axis(1,c(1,2,5,9),c("","1 quarter","1 year","2 years"))
# } else {
#   axis(1,c(1,2,5,9),c("","","",""))
# }
axis(1, at = c(12), labels = c("2.5year"))
axis(2,c(ylims[1],0,ylims[2]),round(c(ylims[1],0,ylims[2]),3))
polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh],IRFs.k1.hdi[2,n,(h+1):1]), col=mcxs1.shade1,border=mcxs1.shade1)
abline(h=0)
lines(hh, IRFs.k1[n,hh],lwd=2,col=mcxs1)
}
#| code-fold: true
#| code-summary: "Show code"
SVcommon.Gibbs.iteration = function(S,Y,X, priors){
# priors is a list containing:
#   h0.v - a positive scalar
#   h0.m - a scalar
#   sigmav.s - a positive scalar
#   sigmav.nu - a positive scalar
#   HH - a TxT matrix
aux     = list(
Y           = Y,
X           = X,
H           = matrix(1,T,1),
h0          = 0,
sigma.v2      = 1,
s           = matrix(1,T,1),
A          = matrix(0, K, N),
Sigma      = matrix(0, K, N),
sigma2    = matrix(1,T,1)
)
posteriors      = list(
H           = matrix(NA,T,S),
sigma2      = matrix(NA,T,S),
s           = matrix(NA,T,S),
h0          = rep(NA,S),
sigma.v2    = rep(NA,S),
A           = array(NA, c(K,N,S)),
Sigma       = array(NA, c(N,N,S))
)
T             = dim(aux$Y)[1]
N             = dim(aux$Y)[2]
K             = dim(X)[2]
# Sampling A and Sigma
kappa.1     = 1
kappa.2     = 100
kappa.3     = 1
A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y
Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)
# Prior distribution specification - Minnesota prior
A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))
A.prior[2:(N + 1), ] = diag(N)
S.prior     = diag(diag(Sigma.hat))
V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))
nu.prior    = 8
#####
alpha.st      = c(1.92677,1.34744,0.73504,0.02266,0-0.85173,-1.97278,-3.46788,-5.55246,-8.68384,-14.65000)
sigma.st      = c(0.11265,0.17788,0.26768,0.40611,0.62699,0.98583,1.57469,2.54498,4.16591,7.33342)
pi.st         = c(0.00609,0.04775,0.13057,0.20674,0.22715,0.18842,0.12047,0.05591,0.01575,0.00115)
for (s in 1:S){
# normal-inverse Wishard posterior parameters
V.bar.inv   = t(aux$X)%*%diag(1/as.vector(aux$sigma2))%*%aux$X + diag(1/diag(V.prior))
V.bar       = solve(V.bar.inv)
A.bar       = V.bar%*%(t(aux$X)%*%diag(1/as.vector(aux$sigma2))%*%aux$Y + diag(1/diag(V.prior))%*%A.prior)
nu.bar      = nrow(aux$Y) + nu.prior
S.bar       = S.prior + t(aux$Y)%*%diag(1/as.vector(aux$sigma2))%*%aux$Y +   t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar
S.bar.inv   = solve(S.bar)
# posterior draws
############################################################
Sigma.posterior.IW     = rWishart(1, df=nu.bar, Sigma=S.bar.inv)
Sigma.posterior.draw   = apply(Sigma.posterior.IW, 3 ,solve)
aux$Sigma              = array(Sigma.posterior.draw,c(N,N,1))
A.norm                 = array(rnorm(prod(c(K,N,1))),c(K,N,1))
L                      = t(chol(V.bar))
aux$A                  = A.bar + L%*%A.norm[,,1]%*%chol(aux$Sigma[,,1])
# Lambda        = solve(chol(S.prior))
Lambda        = solve(chol(aux$Sigma[,,1]))
Z             = rowSums( ( aux$Y - aux$X %*% aux$A ) %*% Lambda ) / sqrt(N)
Y.tilde       = as.vector(log((Z + 0.0000001)^2))
Ytilde.alpha  = as.matrix(Y.tilde - alpha.st[as.vector(aux$s)])
# sampling initial condition
############################################################
V.h0.bar      = 1/((1 / priors$h0.v) + (1 / aux$sigma.v2))
m.h0.bar      = V.h0.bar*((priors$h0.m / priors$h0.v) + (aux$H[1] / aux$sigma.v2))
h0.draw       = rnorm(1, mean = m.h0.bar, sd = sqrt(V.h0.bar))
aux$h0        = h0.draw
# sampling sigma.v2
############################################################
sigma.v2.s    = priors$sigmav.s + sum(c(aux$H[1] - aux$h0, diff(aux$H))^2)
sigma.v2.draw = sigma.v2.s / rchisq(1, priors$sigmav.nu + T)
aux$sigma.v2  = sigma.v2.draw
# sampling auxiliary states
############################################################
Pr.tmp        = simplify2array(lapply(1:10,function(x){
dnorm(Y.tilde, mean = as.vector(aux$H + alpha.st[x]), sd = sqrt(sigma.st[x]), log = TRUE) + log(pi.st[x])
}))
Pr            = t(apply(Pr.tmp, 1, function(x){exp(x - max(x)) / sum(exp(x - max(x)))}))
s.cum         = t(apply(Pr, 1, cumsum))
r             = matrix(rep(runif(T), 10), ncol = 10)
ss            = apply(s.cum < r, 1, sum) + 1
aux$s         = as.matrix(ss)
# sampling log-volatilities using functions for tridiagonal precision matrix
############################################################
Sigma.s.inv   = diag(1 / sigma.st[as.vector(aux$s)])
D.inv         = Sigma.s.inv + (1 / aux$sigma.v2) * priors$HH
b             = as.matrix(Ytilde.alpha / sigma.st[as.vector(aux$s)] + (aux$h0/aux$sigma.v2)*diag(T)[,1])
lead.diag     = diag(D.inv)
sub.diag      = mgcv::sdiag(D.inv, -1)
D.chol        = mgcv::trichol(ld = lead.diag, sd = sub.diag)
D.L           = diag(D.chol$ld)
mgcv::sdiag(D.L,-1) = D.chol$sd
x             = as.matrix(rnorm(T))
a             = forwardsolve(D.L, b)
draw          = backsolve(t(D.L), a + x)
aux$H         = as.matrix(draw)
aux$sigma2    = as.matrix(exp(draw))
posteriors$H[,s]             = aux$H
posteriors$sigma2[,s]        = aux$sigma2
posteriors$s[,s]             = aux$s
posteriors$h0[s]             = aux$h0
posteriors$sigma.v2[s]       = aux$sigma.v2
posteriors$A[,,s]            = aux$A
posteriors$Sigma[,,s]        = aux$Sigma
posteriors$A[,,s]            = aux$A
posteriors$Sigma[,,s]        = aux$Sigma
}
return(posteriors)
}
T             = dim(Y)[1]
H         = diag(T)
sdiag(H,-1) =  -1
HH        = 2*diag(T)
sdiag(HH,-1) =  -1
sdiag(HH,1) =  -1
priors        = list(
h0.v    = 1,
sigmav.s= 1,
sigmav.nu= 1,
h0.v    = 1,
h0.m    = 0 ,
HH      = HH
)
sv1 = SVcommon.Gibbs.iteration(S,Y,X,priors)
A.posterior= sv1$A
B.posterior       = array(NA,c(N,N,S))
B1.posterior = array(NA,c(N,(1+N*p),S))
for (s in 1:S){
cholSigma.s     = chol(sv1$Sigma[,,s])
B.posterior[,,s]= t(cholSigma.s)
B1.posterior[,,s] =  B.posterior[,,s]%*%t(A.posterior[,,s])
}
sv_posterior = list(A.posterior = A.posterior, B.posterior = B.posterior, Sigma.posterior = sv1$Sigma,B1.posterior = B1.posterior)
SV_Narrative_Restriction = NarrativeSignRestrictions(sign.restrictions = c(1,1,0,0,0,1,1,1), sv_posterior,c(16,50,80,156,204),Y,X)
A.posterior = SV_Narrative_Restriction$A.draws
B.posterior = SV_Narrative_Restriction$B.draws
# Calculate the means
Ahcheck_mean <- head(round(apply(A.posterior, 1:2, mean),4))
# Calculate the standard deviations
Ahcheck_sd <- head(round(apply(A.posterior, 1:2, sd),4))
Ahcheck_mean
Ahcheck_sd
# Calculate the means
Bhcheck_mean <- head(round(apply(B.posterior, 1:2, mean),4))
Bhcheck_sd   <- head(round(apply(B.posterior, 1:2, sd),4))
# Calculate the standard deviations
Bhcheck_mean
Bhcheck_sd
# Calculate the means
Bhcheck_mean <- head(round(apply(B.posterior, 1:2, mean),4))
Bhcheck_sd   <- head(round(apply(B.posterior, 1:2, sd),4))
# Calculate the standard deviations
Bhcheck_mean
Bhcheck_sd
par(mfrow=c(2,2), mar=c(4,4,2,2))
plot.ts(A.posterior[3,,][8,], xlab = "Simulation times S", ylab = expression(A[38]), col = "#CC66CC")
hist(A.posterior[3,,][8,], xlab = expression(A[38]), col = "#CC66CC", main = '')
plot.ts(B.posterior[3,,][8,], xlab = "Simulation times S", ylab = expression(B[38]), col = "lightblue")
hist(B.posterior[3,,][8,], xlab = expression(A[38]), col = "lightblue", main = '')
h = 20
IRF.posterior     = array(NA,c(N,N,h+1,S))
IRF.inf.posterior = array(NA,c(N,N,S))
FEVD.posterior    = array(NA,c(N,N,h+1,S))
J                 = cbind(diag(N),matrix(0,N,N*(p-1)))
for (s in 1:S){
A.bold          = rbind(t(A.posterior[2:(1+N*p),,s]),cbind(diag(N*(p-1)),matrix(0,N*(p-1),N)))
IRF.inf.posterior[,,s]          = J %*% solve(diag(N*p)-A.bold) %*% t(J) %*% B.posterior[,,s]
A.bold.power    = A.bold
for (i in 1:(h+1)){
if (i==1){
IRF.posterior[,,i,s]        = B.posterior[,,s]
} else {
IRF.posterior[,,i,s]        = J %*% A.bold.power %*% t(J) %*% B.posterior[,,s]
A.bold.power                = A.bold.power %*% A.bold
}
for (n in 1:N){
for (nn in 1:N){
FEVD.posterior[n,nn,i,s]  = sum(IRF.posterior[n,nn,1:i,s]^2)
}
}
FEVD.posterior[,,i,s]         = diag(1/apply(FEVD.posterior[,,i,s],1,sum))%*%FEVD.posterior[,,i,s]
}
}
FEVD.posterior    = 100*FEVD.posterior
# save(IRF.posterior,IRF.inf.posterior, FEVD.posterior, file="irf-fevd-k002.RData")
save(IRF.posterior,IRF.inf.posterior, FEVD.posterior, file="irf-fevd-k1_narrative.RData")
load("irf-fevd-k1_narrative.RData")
IRFs.k1           = apply(IRF.posterior[,1,,],1:2,mean)
######1st shock is government  spending shock
IRFs.inf.k1       = apply(IRF.inf.posterior[,1,],1,mean)
rownames(IRFs.k1) = colnames(Y)
IRFs.k1.hdi    = apply(IRF.posterior[,1,,],1:2,hdi, credMass=0.68)
hh          = 1:h+1
par(mfrow=c(3,3), mar=c(4,4.5,2,2),cex.axis=1.5, cex.lab=1.5)
# par(mfrow=c(4,2), mar=c(3,3,2,2),cex.axis=1.5, cex.lab=1.5)
for (n in 1:N){
ylims     = range(IRFs.k1[n,hh],IRFs.k1.hdi[,n,hh])
plot(hh,IRFs.k1[n,hh], type="l", ylim=ylims, axes=FALSE, xlab="", ylab=rownames(IRFs.k1)[n])
# if (n==N-1 | n==N){
#   axis(1,c(1,2,5,9),c("","1 quarter","1 year","2 years"))
# } else {
#   axis(1,c(1,2,5,9),c("","","",""))
# }
axis(1, at = c(12), labels = c("2.5year"))
axis(2,c(ylims[1],0,ylims[2]),round(c(ylims[1],0,ylims[2]),3))
polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh],IRFs.k1.hdi[2,n,(h+1):1]), col=mcxs1.shade1,border=mcxs1.shade1)
abline(h=0)
lines(hh, IRFs.k1[n,hh],lwd=2,col=mcxs1)
}
A.posterior = Sign_restritions$A.draws
B.posterior = Sign_restritions$B.draws
# Calculate the means
A4check_mean <- head(round(apply(Sign_restritions$A.draws, 1:2, mean),4))
# Calculate the standard deviations
A4check_sd <- head(round(apply(Sign_restritions$A.draws, 1:2, sd),4))
A4check_mean
A4check_sd
knitr::kable(A4check_mean)
# Calculate the means
A4check_mean <- head(round(apply(Sign_restritions$A.draws, 1:2, mean),4))
# Calculate the standard deviations
A4check_sd <- head(round(apply(Sign_restritions$A.draws, 1:2, sd),4))
A4check_mean
A4check_sd
A4check <- data.frame(Mean = A4check_mean, SD = A4check_sd)
# Convert rownames to a column
A4check <- A4check %>%
rownames_to_column("Matrix_Element")
# Print a labeled table
kable(A4check, caption = "Means and Standard Deviations for Matrix A", digits = 4)
# Print a labeled table
knitr::kable(A4check, caption = "Means and Standard Deviations for Matrix A", digits = 4)
A4check <- data.frame(Mean = A4check_mean, SD = A4check_sd)
# Print a labeled table
knitr::kable(A4check, caption = "Means and Standard Deviations for Matrix A", digits = 4)
A4check <- rbind(A4check_mean, A4check_sd)
# Print a labeled table
knitr::kable(A4check, caption = "Means and Standard Deviations for Matrix A", digits = 4)
# Convert rownames to a column
A4check <- data.frame(Metric = rownames(A4check), A4check)
A4check <- rbind(A4check_mean, A4check_sd)
# Convert rownames to a column
A4check <- data.frame(Metric = rownames(A4check), A4check)
# Update the row names
rownames(A4check) <- c("Mean", "Standard Deviation")
# Print the dataframe
print(A4check)
knitr::kable(A4check, caption = "Means and Standard Deviations for Matrix A", digits = 4)
# Name the rows
rownames(A4check) <- c(paste("Mean", 1:6), paste("SD", 1:6))
# Create a labelled table
kable(A4check, caption = "Top 6: Means, Bottom 6: Standard Deviations for Matrix A", digits = 4)
# Create a labelled table
knit::kable(A4check, caption = "Top 6: Means, Bottom 6: Standard Deviations for Matrix A", digits = 4)
# Create a labelled table
knitr::kable(A4check, caption = "Top 6: Means, Bottom 6: Standard Deviations for Matrix A", digits = 4)
